<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Repairing a $130,000 Server for Fun ‚Äî Maria Patni</title>
  <meta name="description" content="Blog post about repairing a $130,000 server for fun by Maria Patni." />
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" data-route="/styles.css">
  <style>
    :root {
      --bg: #f6f2e9;       /* light beige */
      --fg: #1b4332;       /* dark earthy green */
      --muted: #406a5b;    /* softer green */
      --rule: #d6d0c4;     /* divider */
      --link: #0f5132;     /* link */
      --chip: #e8e2d6;     /* tag chip bg */
      --maxw: 1400px;
      --radius: 12px;
      --shadow: 0 6px 18px rgba(0,0,0,.08);
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Fira Code', monospace; background: var(--bg); color: var(--fg); line-height: 1.6; }
    a { color: var(--link); text-decoration: underline; }

    header { border-bottom: 1px solid var(--rule); padding: 10px 20px; display: flex; gap: 24px; font-size: 16px; }
    header a { color: var(--fg); text-decoration: none; }
    header a:hover { text-decoration: underline; }

    .top-nav { 
      position: absolute; 
      top: 14px; 
      right: 20px; 
      z-index: 1000; 
      display: flex; 
      gap: 24px; 
      font-size: 16px; 
      background: rgba(246, 242, 233, 0.9); 
      backdrop-filter: blur(8px);
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid var(--rule);
    }
    .top-nav a { color: var(--fg); text-decoration: none; font-weight: 500; }
    .top-nav a:hover { text-decoration: underline; }
    .top-nav a.active { color: var(--link); font-weight: 600; }

    .container { max-width: var(--maxw); margin: 0 auto; padding: 24px 24px 24px 100px; }
    .page-title { font-size: 2rem; margin: 60px 0 4px; }
    .subtitle { color: var(--muted); margin: 0 0 24px; font-size: 0.9rem; }
    
    .blog-content {
      margin-top: 32px;
    }
    
    .blog-content p {
      margin: 0 0 16px;
    }
    
    /* Override paragraph margins for terminal captions */
    .terminals-container p {
      margin: 4px 0 0 0 !important;
    }
    
    .blog-content h2 {
      font-size: 1.8rem;
      margin: 32px 0 16px;
      color: var(--fg);
      font-weight: 600;
    }
    
    .blog-content h3 {
      font-size: 1.4rem;
      margin: 24px 0 12px;
      color: var(--fg);
      font-weight: 600;
    }
    
    .blog-content h4 {
      font-size: 1.2rem;
      margin: 20px 0 10px;
      color: var(--muted);
      font-weight: 600;
    }
    
    .blog-content img {
      max-width: 100%;
      height: auto;
      border-radius: var(--radius);
      margin: 24px 0;
      display: block;
    }
    
    /* Override general image margins for terminal images */
    .terminals-container img {
      margin: 0 !important;
    }
    
    .blog-content .terminals-container {
      margin: 20px 0;
    }
    
    .image-row {
      display: flex;
      gap: 16px;
      margin: 24px 0;
      flex-wrap: wrap;
      align-items: flex-start;
    }
    
    .image-row img {
      margin: 0;
      object-fit: contain;
      height: auto;
    }
    
    .image-row img:first-child {
      flex: 0 0 30%;
      max-width: 30%;
    }
    
    .image-row img:last-child {
      flex: 1 1 65%;
      max-width: 65%;
    }
    
    .image-row img:only-child {
      flex: 1 1 45%;
      max-width: 48%;
    }
    
    /* Server disassembly images - right image half size, same height */
    .image-row.server-images {
      align-items: stretch;
    }
    
    .image-row.server-images img:first-child {
      flex: 0 0 50%;
      max-width: 50%;
      height: 100%;
      object-fit: contain;
    }
    
    .image-row.server-images img:last-child {
      flex: 0 0 32.5%;
      max-width: 32.5%;
      height: 100%;
      object-fit: contain;
    }
    
    /* Make both GPU burn images the same height */
    .image-row.gpu-burn {
      align-items: stretch;
    }
    
    .image-row.gpu-burn img {
      height: 100%;
      object-fit: contain;
    }
    
    .image-row.gpu-burn img:first-child {
      flex: 0 0 25%;
      max-width: 25%;
    }
    
    .image-row.gpu-burn img:last-child {
      flex: 1 1 70%;
      max-width: 70%;
    }
    
    /* Image with caption styling */
    .image-with-caption {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 250px;
    }
    
    .image-with-caption img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .image-caption {
      margin-top: 4px;
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
      font-style: italic;
    }
    
    /* Terminal images - completely isolated custom styling */
    .terminals-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      padding: 0;
      width: 100%;
      box-sizing: border-box;
      align-items: flex-start;
    }
    
    .terminals-container .terminal-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin: 0;
      padding: 0;
      min-width: 0;
      align-items: stretch;
    }
    
    .terminals-container .terminal-item img {
      width: 100%;
      height: auto;
      max-height: 1200px;
      object-fit: contain;
      object-position: top;
      margin: 0;
      padding: 0;
      display: block;
      border-radius: 0;
    }
    
    .terminals-container .terminal-item .image-caption {
      margin: 4px 0 0 0 !important;
      padding: 0 !important;
      font-size: 0.85rem;
      color: var(--muted);
      text-align: center;
      font-style: italic;
      line-height: 1.4;
      flex-shrink: 0;
    }
    
    /* Override any paragraph margins inside terminal items */
    .terminals-container .terminal-item p {
      margin: 4px 0 0 0 !important;
      padding: 0 !important;
    }
    
    /* Pumpkin image cropping - show center 80% (cut top and bottom 10%) */
    .pumpkin-crop {
      width: 50%;
      margin: 24px auto;
      display: block;
      overflow: hidden;
      position: relative;
      height: 0;
      padding-bottom: 37.5%; /* Maintain aspect ratio for cropped view */
    }
    
    .pumpkin-crop img {
      width: 100%;
      height: 125%;
      object-fit: cover;
      object-position: center;
      position: absolute;
      top: -12.5%;
      left: 0;
    }
    
    /* OOM errors image cropping - show middle 60% (cut top 35% and bottom 5%) */
    .oom-crop {
      width: 70%;
      margin: 24px auto;
      display: block;
      overflow: hidden;
      position: relative;
      height: 0;
      padding-bottom: 37.5%; /* Maintain aspect ratio for cropped view */
    }
    
    .oom-crop img {
      width: 100%;
      height: 166.67%;
      object-fit: cover;
      object-position: center;
      position: absolute;
      top: -35%;
      left: 0;
    }
    
    @media (max-width: 800px) {
      .image-row {
        flex-direction: column;
      }
      .image-row img {
        min-width: 100%;
        max-width: 100%;
      }
    }
    
    .blog-content ul, .blog-content ol {
      margin: 16px 0;
      padding-left: 24px;
    }
    
    .blog-content li {
      margin: 8px 0;
    }
    
    .blog-content code {
      background: var(--chip);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.9em;
      font-family: 'Fira Code', monospace;
    }
    
    .blog-content pre {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 16px;
      border-radius: var(--radius);
      overflow-x: auto;
      margin: 20px 0;
      border: 1px solid var(--rule);
    }
    
    .blog-content pre code {
      background: transparent;
      padding: 0;
      color: inherit;
    }
    
    .blog-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      table-layout: fixed;
    }
    
    .blog-content table th,
    .blog-content table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--rule);
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .blog-content table th {
      background: var(--chip);
      font-weight: 600;
    }
    
    /* Make the Description & Why column wider */
    .blog-content table th:last-child,
    .blog-content table td:last-child {
      width: 45%;
    }
    
    .blog-content table th:first-child,
    .blog-content table td:first-child {
      width: 20%;
    }
    
    .blog-content table th:nth-child(2),
    .blog-content table td:nth-child(2) {
      width: 20%;
    }
    
    .blog-content table th:nth-child(3),
    .blog-content table td:nth-child(3) {
      width: 15%;
    }
    
    .blog-content blockquote {
      border-left: 3px solid var(--link);
      padding-left: 16px;
      margin: 20px 0;
      color: var(--muted);
      font-style: italic;
    }
    
    .blog-content hr {
      border: none;
      border-top: 2px solid var(--rule);
      margin: 48px 0;
    }
    
    .callout {
      background: var(--chip);
      border-left: 4px solid var(--link);
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: 4px;
    }
    
    .callout strong {
      color: var(--link);
      display: block;
      margin-bottom: 8px;
    }
    
    .highlight {
      background: rgba(15, 81, 50, 0.1);
      border: 2px solid var(--link);
      padding: 16px 20px;
      margin: 24px 0;
      border-radius: var(--radius);
    }
    
    .highlight strong {
      color: var(--link);
    }
    
    .blog-content h2 {
      border-bottom: 2px solid var(--rule);
      padding-bottom: 8px;
      margin-top: 48px;
    }

    footer { display: flex; justify-content: space-around; border-top: 1px solid var(--rule); margin-top: 36px; padding: 18px 0; }
  </style>
</head>
<body>
  <div class="container">

    <!-- Top Navigation Bar -->
    <section class="masthead" style="position: relative;">
      <div data-layout="nav"></div>
    </section>

    <h1 class="page-title">Repairing a $130,000 server</h1>
    <p class="subtitle">a tale of 8 gpus and stubborn BIOS settings</p>

    <div class="blog-content">
      <p>This story actually starts a few weeks ago, at a Pumpkin Carving Party. My roommate and I were invited to my brother's annual Halloween get together, where we spent 3 hours carving these:</p>

      <div class="pumpkin-crop">
        <img src="images/pumpkins.JPG" alt="Carved pumpkins from Halloween party" />
      </div>

      <p>Although we were pretty locked in on the task at hand at the kitchen island, I overheard another conversation happening at the dining table. Someone was asking if anyone knew anything about Gaming PCs, or had built one from scratch. I was intrigued.</p>

      <p>"Why?" I interjected.</p>

      <p>Two of the guests filled me in. Their startup had just received a Comino Grande Server, with 8 GPUs capable of running large Gaussian Splatting Models - the core tech of their company. <strong>However, the server workstation - valued at over 6 figures - came 2 months late, and came broken.</strong> Only 5 of the GPUs could run at any given time, almost doubling time taken for workloads.</p>

      <p>2 additional months of back and forth with a poor customer service team proved unhelpful. That week, they had suggested someone disassemble and reassemble the server rack to resolve any hardware issues, which brought us to the present conversation.</p>

      <p>I recounted my countless hours resolving Nvidia Driver issues during my time in undergrad research.</p>

      <p>"I don't know anything about gaming computers, but I have done quite a bit of GPU debugging in the past. I'm happy to take a look!"</p>

      <p>"See you on Monday."</p>

      <hr />

      <h2>The Investigation Begins</h2>

      <p>Fast forward a few days, and I was sitting on the floor of their chilly Server Room, following along a Youtube tutorial on how to disassemble the server rack. As I opened up the front cover, I kind of realized I had no idea what was going on, and it wasn't really a good idea to take anything apart or touch anything until I understood exactly what was happening. The Comino customer service team recommended doing this - but why? After reading the thread of emails, I realized they didn't have a clue either.</p>

      <p>I asked what the exact issue was. When conducting a GPU burn test, designed to see whether or not all of your GPUs can operate simultaneously at their max capacity for a long period of time, 3 GPUs always failed to initialize. However, all were seen by the OS.</p>

      <div class="image-row server-images">
        <img src="images/pcie_devices.JPEG" alt="PCIe devices configuration" />
        <img src="images/server_dissassembly.JPG" alt="Server disassembly showing internal components" />
      </div>

      <div class="highlight">
        <p>I decided to dig deeper. After running the GPU burn test multiple times and experimenting with different configurations, I made a key discovery: <strong>I could interchange any 5 GPUs and run the burn test successfully. As soon as I added a 6th, initialization began to fail.</strong> Additionally, the system could initialize each GPU individually without any CUDA errors.</p>

        <p>This was the breakthrough I needed - <strong>it wasn't a hardware issue!</strong> The GPUs weren't faulty; this was a configuration problem. The good news? A configuration change could fix everything. The bad news? I had no idea which configuration to change.</p>
      </div>

      <hr />

      <h2>Victory #1: The Memory Fragmentation Mystery</h2>

      <div class="callout">
        <strong>üîç Discovery Timeline</strong>
        <p>After three days of experimenting with different BIOS and OS settings, I finally found the first culprit.</p>
      </div>

      <p>Here's what was happening: When the system boots, the kernel implements a security feature called KASLR (Kernel Address Space Layout Randomization) that scrambles its location in memory to make it harder for hackers to attack. Each GPU needs a large, contiguous chunk of memory (32GB per GPU in our case), but the kernel's memory scrambling was fragmenting these chunks. Without enough contiguous space for all 8 GPUs, the system could only initialize 5.</p>

      <div class="callout">
        <strong>‚ö° The Fix</strong>
        <p>Adding one word to a boot configuration file: <code>"nokaslr"</code></p>
      </div>

      <img src="images/grub-file.jpg" alt="GRUB configuration file with nokaslr setting" />

      <p>After I changed that setting, our burn test worked!</p>

      <div class="image-row gpu-burn">
        <img src="images/success_gpu_burn.png" alt="Successful GPU burn test with all 8 GPUs" />
        <img src="images/success_gpu_burn_2_cover.png" alt="Successful GPU burn test with all 8 GPUs" />
      </div>

      <p>I thought all was well after this.</p>

      <hr />

      <h2>Victory #2: The Rogue Memory Manager</h2>

      <div class="callout">
        <strong>üí• The Crash</strong>
        <p>However, 3 days later the server crashed again while running a memory intensive training run, with a kernel panic. The screen was completely frozen and the machine was unresponsive. I had to boot the device in recovery mode.</p>
      </div>

      <p>After looking through the logs, I learned that the system's memory manager (OOM killer) was not configured correctly. During the training run, the team had configured automatic re-runs if anything failed. The training itself was too memory intensive, which was technically a mistake on our engineer's end, not the system's.</p>

      <p>But here's where it got interesting: when the system reached max memory, the memory manager was set to kill ANY process to free up space - not specifically the one that kept asking for too much memory. Looking at the logs, there was a 2-hour loop where the model would spin up training, ask for too much memory, the OS would desperately try to kill processes to make room, the training would fail, and the cycle would continue.</p>

      <p>Because process killing was randomized, <strong>it eventually randomly killed one of its own kernel processes, causing a kernel panic.</strong></p>

      <div class="oom-crop">
        <img src="images/oom_errors.JPG" alt="OOM killer errors and kernel panic logs" />
      </div>

      <p>The fix was simple - configure the memory manager to be smarter about which processes to kill, and set proper CUDA memory limits to prevent the issue in the first place.</p>

      <img src="images/oom_fix.png" alt="Memory manager configuration settings showing the fix" />

      <p>Great! Now things seem to be working...</p>

      <hr />

      <h2>The Final Boss: The PERR Error Mystery</h2>

      <div class="highlight">
        <p>...but a few days later the server started crashing again.</p>
        <p><strong>RIP.</strong></p>
      </div>

      <p>Every so often, either a few minutes or hours of being online, the server would randomly crash, and was only able to be accessed again after rebooting. Looking at logs from the BIOS event logger, I realized there were errors I had brushed over earlier: PERR (Parity Error) messages.</p>

      <img src="images/perr_errors.png" alt="BIOS event logs showing PERR errors" />

      <p>After more testing, I realized these errors always appeared right after POST (Power-On Self Test), as the OS was being loaded. This meant the problem was at the BIOS level - the firmware had some sort of miscommunication with the hardware it was interfacing with.</p>

      <p>I spent days diving deep into forums, Reddit, Stack Overflow, and every resource I could find. Everything pointed to the same conclusion: "PERR errors = hardware failure. You need to reseat the GPUs or replace them."</p>

      <p>But I wasn't convinced. I had already proven all the GPUs worked individually. This had to be something else.</p>

      <div class="highlight">
        <h3>The Breakthrough</h3>

        <p>After understanding how the motherboard, CPU, and GPUs connected together, I finally found it: <strong>power management settings</strong>.</p>
      </div>

      <p>Here's what was actually happening:</p>

      <p>The CPU has an IOD (I/O Die) chip that handles communication with all the GPUs. There's a BIOS setting called <strong>DF C-States</strong> that enables power saving - when turned on, it allows the IOD chip to go into a low-power "sleep" mode when it's not busy.</p>

      <p>The problem? <strong>If the IOD takes too long to "wake up" when the GPUs try to communicate, the GPU asks "is anyone there?", gets no response within the timeout period, and throws a parity error.</strong></p>

      <p>It's like calling someone who's asleep - if they don't pick up fast enough, you hang up and report a communication failure.</p>


      <p>In addition, there was another setting called <strong>ASPM (Active State Power Management)</strong> that does the same thing for the PCIe connections themselves - the transmitters and receivers that send data between the GPU and CPU can also "sleep" when idle. Same problem: if one side is trying to communicate and the other is asleep, parity error.</p>

      <div class="callout">
        <strong>‚úÖ The Solution</strong>
        <p>Disabling these 2 power-saving settings resolved all parity errors. The system has been running stable for a week now.</p>
      </div>


      <hr />
      <hr />

      <h2>Technical Deep Dive: For Those Debugging Similar Issues</h2>

      <p>If you're dealing with multi-GPU systems, PERR errors, or similar boot issues, here's everything I learned in detail.</p>

      <hr />

      <h3>System Specifications</h3>

      <table>
        <tbody>
          <tr><td><strong>Server:</strong></td><td>Comino Grande</td></tr>
          <tr><td><strong>Motherboard:</strong></td><td>ASRock EPYCD8-2T</td></tr>
          <tr><td><strong>CPU:</strong></td><td>AMD EPYC (64-core)</td></tr>
          <tr><td><strong>GPUs:</strong></td><td>8√ó NVIDIA RTX PRO 6000 (32GB VRAM each = 256GB total)</td></tr>
          <tr><td><strong>RAM:</strong></td><td>512GB DDR5-4800</td></tr>
          <tr><td><strong>OS:</strong></td><td>Ubuntu 24.03</td></tr>
          <tr><td><strong>BIOS:</strong></td><td>ASRock UEFI 2.14</td></tr>
          <tr><td><strong>BMC Firmware:</strong></td><td>1.10.00</td></tr>
        </tbody>
      </table>

      <hr />

      <h3>Problem #1: KASLR Memory Fragmentation</h3>

      <p><strong>Symptoms:</strong> Only 5 of 8 GPUs initialized; any 5 worked but adding a 6th failed; all GPUs worked individually.</p>

      <p><strong>Root Cause:</strong> KASLR randomizes kernel memory location for security, fragmenting the 256GB of contiguous space needed for 8 GPUs (32GB each). This breaks up contiguous memory blocks, preventing all 8 GPUs from getting proper BAR mappings.</p>

      <p><strong>Fix:</strong> Add <code>nokaslr</code> to GRUB command line. See <strong>Final Settings Summary</strong> table for full details. <em>Security trade-off: Removes one kernel security layer (acceptable for internal servers).</em></p>

      <hr />

      <h3>Problem #2: OOM Killer Misconfiguration</h3>

      <p><strong>Symptoms:</strong> Kernel panic after ~3 days; 2-hour loop of process killing; eventually killed critical kernel process.</p>

      <p><strong>Root Cause:</strong> Memory overcommitment allowed system to promise 600GB+ when only 512GB available. OOM killer randomly selected victims (not the memory hog), and auto-restart created a death spiral: training requests 600GB ‚Üí system says "yes" ‚Üí runs out of memory ‚Üí OOM kills random process ‚Üí training restarts ‚Üí loop repeats ‚Üí eventually kills kernel ‚Üí PANIC.</p>

      <p><strong>Fix:</strong> Set <code>vm.overcommit_memory = 2</code> in <code>/etc/sysctl.conf</code> and add <code>PYTORCH_CUDA_ALLOC_CONF=max_split_size_mb:512</code> environment variable. See <strong>Final Settings Summary</strong> table for full details.</p>

      <hr />

      <h3>Problem #3: PCIe PERR Errors</h3>

      <p><strong>Symptoms:</strong> Random crashes every few minutes to hours; errors right after POST during OS boot; BIOS logs showed PERR (Parity Error) messages.</p>

      <p><strong>Why Not Hardware:</strong> All 8 GPUs worked individually; any 5 worked together; errors were consistent and reproducible. This pointed to <strong>timing/power management</strong>, not hardware failure.</p>

      <p><strong>Root Cause:</strong> PERR = Parity Error during PCIe link training. <strong>DF C-States</strong> allows IOD (I/O Die) to sleep, but wake-up takes 10-50Œºs while GPU timeout is 5Œºs ‚Üí timing violation. <strong>ASPM</strong> powers down PCIe transceivers, adding more delay. With 8 GPUs training simultaneously, IOD constantly sleeping/waking created race conditions.</p>

      <p><strong>Fix:</strong> Disable DF C-States and ASPM in BIOS; enable PCIe Early Link Training. See <strong>Final Settings Summary</strong> table for full details and BIOS menu paths.</p>

      <hr />

      <h3>Troubleshooting</h3>

      <div class="callout">
        <strong>üîç Key Diagnostic: Isolate the Problem</strong>
        <p>Check IPMI Event Log timestamps (BMC Web UI ‚Üí System Event Log):</p>
        <ul>
          <li><strong>Errors during POST:</strong> BIOS/firmware issue (hardware initialization, power management, BIOS config)</li>
          <li><strong>Errors after OS boot:</strong> OS-level issue (kernel parameters, drivers, system config)</li>
        </ul>
      </div>

      <div class="terminals-container">
        <div class="terminal-item">
          <img src="images/example_bios_screen.png" alt="Boot screen showing BIOS initialization" />
          <p class="image-caption">Boot: System initialization and hardware detection</p>
        </div>
        <div class="terminal-item">
          <img src="images/POST.png" alt="POST screen showing system initialization" />
          <p class="image-caption">POST: Power-On Self Test phase</p>
        </div>
        <div class="terminal-item">
          <img src="images/uefi_shell.png" alt="UEFI shell interface accessed via IPMI serial console" />
          <p class="image-caption">UEFI Shell: Access BIOS settings via IPMI</p>
        </div>
      </div>

      <p><strong>Access BIOS via IPMI:</strong> <code>sudo apt install ipmitool && ipmitool -I lanplus -H &lt;BMC_IP&gt; -U &lt;user&gt; -P &lt;pass&gt; sol activate</code> ‚Üí Reboot ‚Üí Press DEL/F2 ‚Üí Navigate with arrow keys, Enter, +/-, Esc, F10 to save.</p>

      <table>
        <thead>
          <tr>
            <th>Issue</th>
            <th>Quick Checks</th>
            <th>Solution</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>GPUs Not All Initializing</strong></td>
            <td><code>cat /proc/cmdline | grep nokaslr</code><br/><code>nvidia-smi -L | wc -l</code></td>
            <td>Verify <code>nokaslr</code> active, run <code>sudo update-grub</code> and reboot</td>
          </tr>
          <tr>
            <td><strong>PERR Errors Still Occurring</strong></td>
            <td>Check BIOS via serial console (NOT web UI)<br/><code>dmesg | grep -i "perr"</code></td>
            <td>Verify DF C-States and ASPM are DISABLED via serial console</td>
          </tr>
          <tr>
            <td><strong>Kernel Panic / OOM Crashes</strong></td>
            <td><code>sysctl vm.overcommit_memory</code><br/><code>dmesg | grep -i "oom"</code></td>
            <td>Set <code>vm.overcommit_memory = 2</code> and add CUDA memory limits</td>
          </tr>
          <tr>
            <td><strong>Settings Revert After Reboot</strong></td>
            <td>Check BIOS via serial console</td>
            <td>ASRock web UI bug - always use IPMI serial console for BIOS changes</td>
          </tr>
          <tr>
            <td><strong>ASPM in Multiple Menus</strong></td>
            <td>Check all BIOS menus</td>
            <td>Change the one in <strong>AMD CBS ‚Üí NBIO ‚Üí PCIe Configuration</strong> (this is the one that matters)</td>
          </tr>
          <tr>
            <td><strong>Global C-States vs DF C-States</strong></td>
            <td>Check both settings</td>
            <td>Global C-States = CPU core power (safe to enable)<br/>DF C-States = I/O Die power (<strong>MUST DISABLE</strong>)</td>
          </tr>
        </tbody>
      </table>

      <hr />

      <h3>Final Settings Summary</h3>

      <h4>BIOS Settings (via Serial Console ONLY)</h4>

      <table>
        <thead>
          <tr>
            <th>Menu Path</th>
            <th>Setting</th>
            <th>Value</th>
            <th>Description & Why</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="3"><strong>AMD CBS ‚Üí DF Common Options</strong></td>
            <td>DF C-States</td>
            <td><strong>DISABLED</strong></td>
            <td><strong>‚ö° Critical fix for Problem #3:</strong> Controls I/O Die (IOD) chip power management. When enabled, IOD can "sleep" to save power, but wake-up takes 10-50Œºs while GPU timeout is 5Œºs, causing PERR errors during PCIe link training. Disabling keeps IOD awake, preventing timing violations. Trade-off: ~5-10W higher idle power.</td>
          </tr>
          <tr>
            <td>APBDIS</td>
            <td><strong>1</strong></td>
            <td>Disables additional power gating mechanisms. Ensures more stable PCIe operation by preventing power state transitions that could interrupt communication.</td>
          </tr>
          <tr>
            <td>DfPstate</td>
            <td><strong>0</strong></td>
            <td>Disables Data Fabric P-states (power/performance states). Keeps the data fabric running at full speed, preventing slowdowns that could affect PCIe communication timing.</td>
          </tr>
          <tr>
            <td rowspan="3"><strong>AMD CBS ‚Üí NBIO ‚Üí PCIe Configuration</strong></td>
            <td>PCIe Early Link Training</td>
            <td><strong>ENABLED</strong></td>
            <td><strong>‚ö° Critical for multi-GPU stability:</strong> Starts PCIe initialization earlier in the boot process, providing more time for link training. Essential for systems with 8 GPUs where timing windows are tight. Gives each GPU more opportunity to successfully negotiate speed and establish connection.</td>
          </tr>
          <tr>
            <td>PCIe Link Speed</td>
            <td><strong>Auto</strong></td>
            <td>Allows the system to automatically negotiate the optimal PCIe generation (Gen3/Gen4) for each device. Provides best compatibility and performance without manual configuration.</td>
          </tr>
          <tr>
            <td>ASPM</td>
            <td><strong>DISABLED</strong></td>
            <td><strong>‚ö° Critical fix for Problem #3:</strong> Active State Power Management powers down PCIe transceivers (transmitters/receivers) when idle. Combined with IOD sleep, this creates guaranteed timing violations during boot when 8 GPUs are training simultaneously. Disabling keeps transceivers powered, eliminating ASPM-related PERR errors. Trade-off: ~2-3W per GPU (~20W total).</td>
          </tr>
          <tr>
            <td><strong>AMD CBS ‚Üí NBIO ‚Üí GFX Configuration</strong></td>
            <td>PCIe Resizable BAR Support</td>
            <td><strong>ENABLED</strong></td>
            <td>Enables Resizable Base Address Register (ReBAR), allowing the CPU to access the entire GPU VRAM (32GB per GPU) in a single transaction instead of being limited to 256MB chunks. Provides 10-15% performance improvement in some workloads. Requires "Above 4G Decoding" to be enabled.</td>
          </tr>
          <tr>
            <td rowspan="2"><strong>Advanced ‚Üí PCI Subsystem Settings</strong></td>
            <td>Above 4G Decoding</td>
            <td><strong>ENABLED</strong></td>
            <td>Allows memory mapping above the 4GB address space limit. Required for Resizable BAR to function, as it enables the system to map large GPU memory regions (32GB per GPU) that exceed traditional addressing limits.</td>
          </tr>
          <tr>
            <td>Resizable BAR Support</td>
            <td><strong>ENABLED</strong></td>
            <td>Must be enabled here AND in AMD CBS ‚Üí NBIO ‚Üí GFX Configuration. This setting in the Advanced menu enables ReBAR at the PCI subsystem level, while the AMD CBS setting enables it at the chipset level. Both are required for full functionality.</td>
          </tr>
          <tr>
            <td><strong>Advanced ‚Üí Chipset Configuration</strong></td>
            <td>IOMMU</td>
            <td><strong>ENABLED</strong></td>
            <td>Input-Output Memory Management Unit provides hardware-level memory isolation and translation. Required for GPU passthrough to VMs (Proxmox, QEMU/KVM) and improves security by isolating device memory access. Also enables better GPU performance in some scenarios.</td>
          </tr>
          <tr>
            <td rowspan="2"><strong>AMD CBS ‚Üí CPU Configuration</strong></td>
            <td>Core Performance Boost</td>
            <td><strong>Auto or Enabled</strong></td>
            <td>Allows CPU cores to dynamically boost above their base frequency when thermal and power headroom is available. Improves performance for workloads that can benefit from higher clock speeds. Auto mode lets the system decide, which is fine for most workloads.</td>
          </tr>
          <tr>
            <td>Global C-States</td>
            <td><strong>Can be enabled</strong></td>
            <td><strong>Important distinction:</strong> Global C-States control CPU core power states (different from DF C-States which control I/O Die). These are safe to enable as they only affect CPU cores sleeping, not PCIe communication. Enabling saves power without affecting GPU initialization or PCIe timing.</td>
          </tr>
        </tbody>
      </table>

      <h4>OS Settings</h4>

      <table>
        <thead>
          <tr>
            <th>Configuration File</th>
            <th>Setting</th>
            <th>Value</th>
            <th>Description & Why</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="6"><strong>/etc/default/grub</strong><br/><code>GRUB_CMDLINE_LINUX_DEFAULT</code></td>
            <td><code>quiet splash</code></td>
            <td>Enabled</td>
            <td>Suppresses verbose boot messages and shows splash screen. Provides cleaner boot experience without affecting functionality.</td>
          </tr>
          <tr>
            <td><code>iommu=pt</code></td>
            <td>Enabled</td>
            <td>Sets IOMMU to passthrough mode. Required for optimal GPU performance and enables GPU passthrough to VMs. In passthrough mode, devices are directly mapped without translation overhead.</td>
          </tr>
          <tr>
            <td><code>pcie_aspm=off</code></td>
            <td>Enabled</td>
            <td>Disables Active State Power Management at the kernel level. Redundant with BIOS ASPM=DISABLED but ensures ASPM stays off even if BIOS setting is missed or reverted. Prevents kernel from re-enabling ASPM during runtime.</td>
          </tr>
          <tr>
            <td><code>nvidia.NVreg_EnableResizableBar=1</code></td>
            <td>Enabled</td>
            <td>Enables Resizable BAR support in the NVIDIA driver. Required for ReBAR functionality even when BIOS settings are correct. Without this, the driver won't use ReBAR even if hardware supports it.</td>
          </tr>
          <tr>
            <td><code>nokaslr</code></td>
            <td>Enabled</td>
            <td><strong>‚ö° Critical fix for Problem #1:</strong> Disables Kernel Address Space Layout Randomization. KASLR randomizes kernel memory location for security, but fragments contiguous memory needed for GPU BAR mappings (32GB per GPU). With 8 GPUs needing 256GB of contiguous space, KASLR breaks this into fragments, allowing only 5 GPUs to initialize. Disabling preserves contiguous memory blocks. Security trade-off: removes one kernel security layer (acceptable for internal servers).</td>
          </tr>
          <tr>
            <td><code>pci=realloc</code></td>
            <td>Enabled</td>
            <td>Enables PCI BAR reallocation. Allows the kernel to reallocate Base Address Registers after initial assignment, which is necessary for Resizable BAR to work properly. Helps kernel allocate large BARs (32GB) for each GPU.</td>
          </tr>
          <tr>
            <td><strong>/etc/sysctl.conf</strong></td>
            <td><code>vm.overcommit_memory</code></td>
            <td><strong>2</strong></td>
            <td><strong>‚ö° Critical fix for Problem #2:</strong> Disables memory overcommitment. Default (0 or 1) allows system to promise more memory than available, leading to OOM killer randomly killing processes when memory runs out. Value of 2 means "never overcommit" - system denies excessive memory requests upfront instead of crashing later. Prevents the 2-hour death spiral where training requests 600GB, system says "yes", runs out of memory, OOM kills random processes (eventually kernel), causing panic.</td>
          </tr>
          <tr>
            <td><strong>Environment Variable</strong><br/>(.bashrc or training scripts)</td>
            <td><code>PYTORCH_CUDA_ALLOC_CONF</code></td>
            <td><code>max_split_size_mb:512</code></td>
            <td><strong>‚ö° Critical fix for Problem #2:</strong> Limits CUDA memory allocation chunk size to 512MB. Prevents PyTorch from requesting massive contiguous GPU memory blocks that exceed available system memory. Works with <code>vm.overcommit_memory=2</code> to prevent OOM crashes. Without this, training scripts can request 600GB+ which triggers the OOM killer even with overcommit disabled.</td>
          </tr>
        </tbody>
      </table>

      <hr />

      <h3>TLDR</h3>

      <p><strong>Problem #1: KASLR Memory Fragmentation</strong></p>
      <ul>
        <li>Root cause: Kernel randomization broke contiguous memory</li>
        <li>Fix: <code>nokaslr</code> kernel parameter</li>
        <li>Result: All 8 GPUs get proper 32GB BAR mappings</li>
      </ul>

      <p><strong>Problem #2: OOM Killer</strong></p>
      <ul>
        <li>Root cause: Memory overcommitment + random victim selection</li>
        <li>Fix: <code>vm.overcommit_memory = 2</code> + CUDA limits</li>
        <li>Result: System handles memory pressure gracefully</li>
      </ul>

      <p><strong>Problem #3: PERR Errors</strong></p>
      <ul>
        <li>Root cause: IOD and PCIe transceivers sleeping during link training</li>
        <li>Fix: Disable DF C-States + ASPM + Enable Early Link Training</li>
        <li>Result: All components stay active during boot, no timing violations</li>
      </ul>

      <hr />

      <p><strong>The system has been running stable for 1 week now, handling full GPU workloads without any crashes or errors. Hopefully this saves someone else the weeks of troubleshooting I went through!</strong></p>
    </div>

    <div data-layout="footer"></div>
  </div>
  <script src="../../menu.js"></script>
</body>
</html>

